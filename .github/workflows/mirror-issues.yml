name: "Mirror Issues from Original Repo"

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch: # Allow manual triggering

permissions:
  issues: write
  contents: write
  pull-requests: read

env:
  ORIGINAL_REPO: okd-project/okd
  TRACKING_FILE: .github/mirrored-issues.json

jobs:
  mirror-issues:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch and mirror issues
        id: mirror
        env:
          ORIGINAL_OWNER: okd-project
          ORIGINAL_REPO: okd
          FORK_OWNER: kenjpais
          FORK_REPO: okd
          TRACKING_FILE: .github/mirrored-issues.json
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const trackingFile = process.env.TRACKING_FILE || '.github/mirrored-issues.json';
            const originalOwner = process.env.ORIGINAL_OWNER;
            const originalRepo = process.env.ORIGINAL_REPO;
            const forkOwner = process.env.FORK_OWNER;
            const forkRepo = process.env.FORK_REPO;
            
            // Load tracking data
            let trackedIssues = { processed: [] };
            if (fs.existsSync(trackingFile)) {
              try {
                trackedIssues = JSON.parse(fs.readFileSync(trackingFile, 'utf8'));
              } catch (e) {
                core.warning(`Failed to read tracking file: ${e.message}`);
              }
            }
            
            // Fetch open issues from original repository (with pagination)
            // Note: github object is authenticated with GITHUB_TOKEN (works for public repos)
            // For reading public repos, GITHUB_TOKEN works fine and has higher rate limits than unauthenticated
            let allIssues = [];
            let page = 1;
            const perPage = 100;
            
            while (true) {
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: originalOwner,
                repo: originalRepo,
                state: 'open',
                sort: 'created',
                direction: 'desc',
                per_page: perPage,
                page: page
              });
              
              if (issues.length === 0) {
                break;
              }
              
              allIssues = allIssues.concat(issues);
              
              // If we got fewer than perPage results, we've reached the end
              if (issues.length < perPage) {
                break;
              }
              
              page++;
            }
            
            const issues = allIssues;
            core.info(`Found ${issues.length} open issues in ${originalOwner}/${originalRepo}`);
            
            let newIssuesCount = 0;
            let skippedCount = 0;
            const newlyProcessed = [];
            
            // Process each issue
            for (const issue of issues) {
              // Skip pull requests
              if (issue.pull_request) {
                continue;
              }
              
              const issueId = issue.number;
              
              // Check if already processed
              if (trackedIssues.processed.includes(issueId)) {
                skippedCount++;
                continue;
              }
              
              try {
                // Create mirrored issue in fork
                const title = `[ORIGINAL #${issueId}] ${issue.title}`;
                const originalUrl = issue.html_url;
                const originalUser = issue.user.login;
                const createdAt = new Date(issue.created_at).toISOString();
                
                const body = `**This issue was automatically mirrored from the original repository.**\n\n` +
                  `**Original Issue:** #${issueId} in [${originalOwner}/${originalRepo}](${originalUrl})\n` +
                  `**Original Author:** @${originalUser}\n` +
                  `**Created:** ${createdAt}\n\n` +
                  `---\n\n` +
                  `${issue.body || '*No description provided.*'}\n\n` +
                  `---\n\n` +
                  `*This is an automated mirror. Please refer to the [original issue](${originalUrl}) for updates and discussions.*`;
                
                // Try to create issue with kind/bug label, fallback to no label if it doesn't exist
                let newIssue;
                try {
                  const { data } = await github.rest.issues.create({
                    owner: forkOwner,
                    repo: forkRepo,
                    title: title,
                    body: body,
                    labels: ['kind/bug'] // Automatically add kind/bug to trigger triage workflow
                  });
                  newIssue = data;
                } catch (labelError) {
                  // If label doesn't exist, create issue without label
                  if (labelError.message && labelError.message.includes('label')) {
                    core.warning(`Label 'kind/bug' not found, creating issue without label. Issue #${issueId}`);
                    const { data } = await github.rest.issues.create({
                      owner: forkOwner,
                      repo: forkRepo,
                      title: title,
                      body: body
                    });
                    newIssue = data;
                    // Try to add label separately (it might exist but failed for another reason)
                    try {
                      await github.rest.issues.addLabels({
                        owner: forkOwner,
                        repo: forkRepo,
                        issue_number: newIssue.number,
                        labels: ['kind/bug']
                      });
                    } catch (e) {
                      core.warning(`Could not add kind/bug label to issue #${newIssue.number}: ${e.message}`);
                    }
                  } else {
                    throw labelError;
                  }
                }
                
                core.info(`Created mirrored issue #${newIssue.number} for original issue #${issueId}`);
                newIssuesCount++;
                newlyProcessed.push(issueId);
                
                // Small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 1000));
                
              } catch (error) {
                core.error(`Failed to mirror issue #${issueId}: ${error.message}`);
                // Continue with next issue
              }
            }
            
            // Update tracking file
            if (newlyProcessed.length > 0) {
              trackedIssues.processed.push(...newlyProcessed);
              trackedIssues.lastUpdated = new Date().toISOString();
              
              // Ensure directory exists
              const dir = path.dirname(trackingFile);
              if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
              }
              
              fs.writeFileSync(trackingFile, JSON.stringify(trackedIssues, null, 2));
              core.info(`Updated tracking file with ${newlyProcessed.length} new issues`);
            }
            
            core.setOutput('new_issues', newIssuesCount);
            core.setOutput('skipped', skippedCount);
            core.setOutput('has_changes', newlyProcessed.length > 0 ? 'true' : 'false');
            core.summary.addRaw(`
              ## Issue Mirroring Summary
              
              - **New issues mirrored:** ${newIssuesCount}
              - **Issues skipped (already processed):** ${skippedCount}
              - **Total issues checked:** ${issues.length}
              
              ${newIssuesCount > 0 ? `✅ Successfully mirrored ${newIssuesCount} issue(s) from ${originalOwner}/${originalRepo}` : 'ℹ️ No new issues to mirror'}
            `);
            await core.summary.write();

      - name: Commit and push tracking file
        if: steps.mirror.outputs.has_changes == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .github/mirrored-issues.json
          git commit -m "Update mirrored issues tracking: ${{ steps.mirror.outputs.new_issues }} new issues" || exit 0
          git push || exit 0

