name: "Issue Triage"
run-name: "AI Triage for Issue #${{ github.event.issue.number }}"

on:
  issues:
    types: [opened, reopened, edited, labeled]

concurrency:
  group: ai-triage-${{ github.event.issue.number }}
  cancel-in-progress: true

permissions:
  issues: write
  models: read
  contents: read

jobs:
  ai-triage:
    # Always run for issue events - skip logic handled in steps
    if: github.event_name == 'issues'
    runs-on: ubuntu-latest
    outputs:
      triage_result: ${{ steps.set-output.outputs.triage_result }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Ensure triage label exists
        if: github.event.action != 'labeled' || (github.event.action == 'labeled' && (github.event.label == null || github.event.label.name != 'triage/needs-triage'))
        uses: actions/github-script@v7
        with:
          script: |
            // Skip if this is a labeled event with the wrong label
            if (context.payload.action === 'labeled' && context.payload.label && context.payload.label.name !== 'triage/needs-triage') {
              core.info('Skipping - labeled event with different label');
              process.exit(0);
            }
            
            // Add the trigger label if it doesn't already exist
            // This ensures the label is present before the AI assessment runs
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              labels: ['triage/needs-triage']
            });
            
            // Wait a moment for GitHub API to propagate
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Verify the label is present
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
            });
            
            const labels = issue.labels.map(l => l.name);
            if (!labels.includes('triage/needs-triage')) {
              throw new Error('triage/needs-triage label was not found after adding it');
            }

      - name: Check if we should run AI assessment
        id: check-run
        run: |
          if [ "${{ github.event.action }}" = "labeled" ]; then
            LABEL_NAME="${{ github.event.label.name }}"
            if [ -z "$LABEL_NAME" ] || [ "$LABEL_NAME" != "triage/needs-triage" ]; then
              echo "should_run=false" >> $GITHUB_OUTPUT
              echo "Skipping AI assessment - wrong label or no label"
            else
              echo "should_run=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "should_run=true" >> $GITHUB_OUTPUT
          fi

      - name: AI Issue Assessment
        if: steps.check-run.outputs.should_run == 'true'
        id: ai-assessment
        uses: github/ai-assessment-comment-labeler@v1.0.1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          issue_number: ${{ github.event.issue.number }}
          issue_body: ${{ github.event.issue.body }}
          repo_name: ${{ github.event.repository.name }}
          owner: ${{ github.repository_owner }}
          ai_review_label: 'triage/needs-triage'
          prompts_directory: './.github/prompts'
          labels_to_prompts_mapping: 'kind/bug,bug-triage.prompt.yml'
          model: 'openai/gpt-4o-mini'
          max_tokens: 300

      - name: Post Assessment Summary
        if: always()
        id: set-output
        uses: actions/github-script@v7
        env:
          ASSESSMENT_OUTPUT: ${{ steps.ai-assessment.outputs.ai_assessments }}
        with:
          script: |
            let assessments = [];
            try {
              assessments = JSON.parse(process.env.ASSESSMENT_OUTPUT || '[]');
            } catch (e) {
              core.warning(`Failed to parse assessment output: ${e.message}`);
              assessments = [];
            }
            if (assessments.length > 0) {
              let summary = '## AI Triage Assessment for OKD\n\n';
              summary += '**Project:** OKD - The Community Distribution of Kubernetes\n\n';
              
              let triageText = '';
              for (const assessment of assessments) {
                summary += `### ${assessment.prompt}\n`;
                summary += `**Label Applied:** \`${assessment.assessmentLabel}\`\n\n`;
                summary += `**Assessment:**\n${assessment.response}\n\n`;
                summary += '---\n\n';
                
                // Create simplified text for Slack
                triageText += `*${assessment.assessmentLabel}*\n${assessment.response.substring(0, 300)}...\n\n`;
              }
              
              summary += '\n*This assessment was generated using AI to help maintain issue quality in the OKD project.*\n';
              core.summary.addRaw(summary);
              await core.summary.write();
              
              // Set output for Slack notification
              core.setOutput('triage_result', triageText.replace(/\n/g, '\\n'));
            } else {
              core.setOutput('triage_result', 'No triage assessment available');
            }

  notify-slack:
    if: always() && github.event_name == 'issues'
    runs-on: ubuntu-latest
    needs: [ai-triage]
    steps:
      - name: Format Labels
        id: format-labels
        uses: actions/github-script@v7
        with:
          script: |
            const labels = context.payload.issue.labels || [];
            const labelNames = labels.map(l => l.name).join(',') || 'None';
            core.setOutput('labels', labelNames);

      - name: Send to Slack
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          TRIAGE_RESULT: ${{ needs.ai-triage.outputs.triage_result }}
        run: |
          # Escape quotes for JSON
          TITLE=$(echo "${{ github.event.issue.title }}" | sed 's/"/\\"/g')
          TRIAGE=$(echo "$TRIAGE_RESULT" | sed 's/"/\\"/g')
          
          # Create JSON payload
          cat > /tmp/slack_payload.json << EOF
          {
            "text": "*New OKD Issue Created*",
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "New OKD Issue #${{ github.event.issue.number }}"
                }
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Title:*\n${TITLE}"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Author:*\n${{ github.event.issue.user.login }}"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Labels:*\n${{ steps.format-labels.outputs.labels }}"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Repository:*\n${{ github.repository }}"
                  }
                ]
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "<${{ github.event.issue.html_url }}|View Issue on GitHub>"
                }
              },
              {
                "type": "divider"
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*AI Triage Assessment:*\n${TRIAGE}"
                }
              }
            ]
          }
          EOF
          
          # Send to Slack
          curl -X POST \
            -H 'Content-type: application/json' \
            --data @/tmp/slack_payload.json \
            "$SLACK_WEBHOOK_URL" || echo "Slack notification failed but continuing"
        continue-on-error: true

