name: "Issue Triage"
run-name: "AI Triage for Issue #${{ github.event.issue.number }}"

on:
  issues:
    types: [opened, reopened, edited]

concurrency:
  group: ai-triage-${{ github.event.issue.number }}
  cancel-in-progress: true

permissions:
  issues: write
  models: read
  contents: read

jobs:
  ai-triage:
    if: github.event_name == 'issues'
    runs-on: ubuntu-latest
    outputs:
      triage_result: ${{ steps.set-output.outputs.triage_result }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Ensure triage label exists
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = context.payload.issue.number;
            
            // Fetch current issue state to get latest labels
            const { data: currentIssue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
            });
            
            const currentLabels = currentIssue.labels.map(l => l.name);
            
            // Always ensure triage/needs-triage label exists (idempotent operation)
            // This ensures the AI assessment can run for opened, edited, and reopened issues
            if (!currentLabels.includes('triage/needs-triage')) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: ['triage/needs-triage']
              });
            }
            
            // Verify the label is present by fetching the issue again
            // This ensures GitHub API has propagated the label before the next step
            let retries = 3;
            let labelFound = false;
            
            while (retries > 0 && !labelFound) {
              const { data: verifiedIssue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
              });
              
              const verifiedLabels = verifiedIssue.labels.map(l => l.name);
              if (verifiedLabels.includes('triage/needs-triage')) {
                labelFound = true;
                break;
              }
              
              // Wait a bit before retrying (GitHub API might need a moment to propagate)
              await new Promise(resolve => setTimeout(resolve, 500));
              retries--;
            }
            
            if (!labelFound) {
              throw new Error('triage/needs-triage label not found on issue after adding it');
            }

      - name: AI Issue Assessment
        id: ai-assessment
        uses: github/ai-assessment-comment-labeler@v1.0.1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          issue_number: ${{ github.event.issue.number }}
          issue_body: ${{ github.event.issue.body }}
          repo_name: ${{ github.event.repository.name }}
          owner: ${{ github.repository_owner }}
          ai_review_label: 'triage/needs-triage'
          prompts_directory: './.github/prompts'
          labels_to_prompts_mapping: 'kind/bug,bug-triage.prompt.yml'
          model: 'openai/gpt-4o-mini'
          max_tokens: 300

      - name: Post Assessment Summary
        if: always()
        id: set-output
        uses: actions/github-script@v7
        env:
          ASSESSMENT_OUTPUT: ${{ steps.ai-assessment.outputs.ai_assessments }}
        with:
          script: |
            let assessments = [];
            try {
              assessments = JSON.parse(process.env.ASSESSMENT_OUTPUT || '[]');
            } catch (e) {
              core.warning(`Failed to parse assessment output: ${e.message}`);
              assessments = [];
            }
            if (assessments.length > 0) {
              let summary = '## AI Triage Assessment for OKD\n\n';
              summary += '**Project:** OKD - The Community Distribution of Kubernetes\n\n';
              
              let triageText = '';
              for (const assessment of assessments) {
                summary += `### ${assessment.prompt}\n`;
                summary += `**Label Applied:** \`${assessment.assessmentLabel}\`\n\n`;
                summary += `**Assessment:**\n${assessment.response}\n\n`;
                summary += '---\n\n';
                
                // Create simplified text for Slack
                triageText += `*${assessment.assessmentLabel}*\n${assessment.response.substring(0, 300)}...\n\n`;
              }
              
              summary += '\n*This assessment was generated using AI to help maintain issue quality in the OKD project.*\n';
              core.summary.addRaw(summary);
              await core.summary.write();
              
              // Set output for Slack notification
              core.setOutput('triage_result', triageText.replace(/\n/g, '\\n'));
            } else {
              core.setOutput('triage_result', 'No triage assessment available');
            }

  notify-slack:
    if: always() && github.event_name == 'issues'
    runs-on: ubuntu-latest
    needs: [ai-triage]
    steps:
      - name: Format Labels
        id: format-labels
        uses: actions/github-script@v7
        with:
          script: |
            const labels = context.payload.issue.labels || [];
            const labelNames = labels.map(l => l.name).join(',') || 'None';
            core.setOutput('labels', labelNames);

      - name: Send to Slack
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          TRIAGE_RESULT: ${{ needs.ai-triage.outputs.triage_result }}
        run: |
          # Escape quotes for JSON
          TITLE=$(echo "${{ github.event.issue.title }}" | sed 's/"/\\"/g')
          TRIAGE=$(echo "$TRIAGE_RESULT" | sed 's/"/\\"/g')
          
          # Create JSON payload
          cat > /tmp/slack_payload.json << EOF
          {
            "text": "*New OKD Issue Created*",
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "New OKD Issue #${{ github.event.issue.number }}"
                }
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Title:*\n${TITLE}"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Author:*\n${{ github.event.issue.user.login }}"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Labels:*\n${{ steps.format-labels.outputs.labels }}"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Repository:*\n${{ github.repository }}"
                  }
                ]
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "<${{ github.event.issue.html_url }}|View Issue on GitHub>"
                }
              },
              {
                "type": "divider"
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*AI Triage Assessment:*\n${TRIAGE}"
                }
              }
            ]
          }
          EOF
          
          # Send to Slack
          curl -X POST \
            -H 'Content-type: application/json' \
            --data @/tmp/slack_payload.json \
            "$SLACK_WEBHOOK_URL" || echo "Slack notification failed but continuing"
        continue-on-error: true

