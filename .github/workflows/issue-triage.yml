name: "Issue Triage"
run-name: "AI Triage for Issue #${{ github.event.issue.number }}"

on:
  issues:
    # Trigger ONLY when an issue has been labeled
    types: [labeled]

concurrency:
  group: ai-triage-${{ github.event.issue.number }}
  cancel-in-progress: true

permissions:
  issues: write
  models: read
  contents: read

jobs:
  ai-triage:
    runs-on: ubuntu-latest
    outputs:
      triage_result: ${{ steps.set-output.outputs.triage_result }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: AI Issue Assessment
        id: ai-assessment
        uses: github/ai-assessment-comment-labeler@v1.0.1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          issue_number: ${{ github.event.issue.number }}
          issue_body: ${{ github.event.issue.body }}
          repo_name: ${{ github.event.repository.name }}
          owner: ${{ github.repository_owner }}
          ai_review_label: 'kind/bug'
          prompts_directory: './.github/prompts'
          labels_to_prompts_mapping: 'kind/bug,bug-triage.prompt.yml,kind/bug,priority-router.prompt.yml'
          model: 'openai/gpt-4o-mini'
          max_tokens: 300

      - name: Ensure kind/bug label persists
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = context.payload.issue.number;
            const labelToPreserve = 'kind/bug';
            
            // Check if the workflow was triggered by kind/bug label
            const triggerLabel = context.payload.label?.name;
            const wasTriggeredByTargetLabel = triggerLabel === labelToPreserve;
            
            // Get current issue labels to check if kind/bug is present
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
            });
            
            const currentLabels = issue.labels.map(l => l.name);
            
            // Only preserve kind/bug if:
            // 1. The workflow was triggered by kind/bug label, OR
            // 2. kind/bug was already present on the issue (from event payload)
            const wasPresentInitially = context.payload.issue?.labels?.some(
              l => l.name === labelToPreserve
            ) || false;
            
            if ((wasTriggeredByTargetLabel || wasPresentInitially) && !currentLabels.includes(labelToPreserve)) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: [labelToPreserve],
              });
              core.info(`Re-added ${labelToPreserve} label to issue #${issueNumber} (was removed by AI action)`);
            } else if (currentLabels.includes(labelToPreserve)) {
              core.info(`${labelToPreserve} label already present on issue #${issueNumber}`);
            } else {
              core.info(`${labelToPreserve} label not present and not required for this issue`);
            }

      - name: Post Assessment Summary
        id: set-output
        if: always()
        uses: actions/github-script@v7
        env:
          ASSESSMENT_OUTPUT: ${{ steps.ai-assessment.outputs.ai_assessments }}
        with:
          script: |
            let assessments = [];
            try {
              const output = process.env.ASSESSMENT_OUTPUT || '[]';
              assessments = JSON.parse(output);
            } catch (e) {
              core.warning(`Failed to parse assessment output: ${e.message}`);
              assessments = [];
            }
            
            if (assessments.length === 0) {
              core.setOutput('triage_result', 'No triage assessment available');
              return;
            }
            
            let summary = '## AI Triage Assessment for OKD\n\n**Project:** OKD - The Community Distribution of Kubernetes\n\n';
            let triageText = '';
            
            for (const assessment of assessments) {
              summary += `### ${assessment.prompt}\n**Label Applied:** \`${assessment.assessmentLabel}\`\n\n**Assessment:**\n${assessment.response}\n\n---\n\n`;
              triageText += `*${assessment.assessmentLabel}*\n${assessment.response.substring(0, 300)}...\n\n`;
            }
            
            summary += '\n*This assessment was generated using AI to help maintain issue quality in the OKD project.*\n';
            core.summary.addRaw(summary);
            await core.summary.write();
            core.setOutput('triage_result', triageText.replace(/\n/g, '\\n'));

  notify-slack:
    if: always()
    runs-on: ubuntu-latest
    needs: [ai-triage]
    steps:
      - name: Send to Slack
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          TRIAGE_RESULT: ${{ needs.ai-triage.outputs.triage_result }}
        uses: actions/github-script@v7
        with:
          script: |
            const labels = context.payload.issue.labels?.map(l => l.name).join(',') || 'None';
            const triage = (process.env.TRIAGE_RESULT || '').replace(/\\n/g, '\n');
            
            const payload = {
              text: "*New OKD Issue Created*",
              blocks: [
                {
                  type: "header",
                  text: { type: "plain_text", text: `New OKD Issue #${context.payload.issue.number}` }
                },
                {
                  type: "section",
                  fields: [
                    { type: "mrkdwn", text: `*Title:*\n${context.payload.issue.title}` },
                    { type: "mrkdwn", text: `*Author:*\n${context.payload.issue.user.login}` },
                    { type: "mrkdwn", text: `*Labels:*\n${labels}` },
                    { type: "mrkdwn", text: `*Repository:*\n${context.repo.owner}/${context.repo.repo}` }
                  ]
                },
                {
                  type: "section",
                  text: { type: "mrkdwn", text: `<${context.payload.issue.html_url}|View Issue on GitHub>` }
                },
                { type: "divider" },
                {
                  type: "section",
                  text: { type: "mrkdwn", text: `*AI Triage Assessment:*\n${triage}` }
                }
              ]
            };
            
            await fetch(process.env.SLACK_WEBHOOK_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            }).catch(err => core.warning(`Slack notification failed: ${err.message}`));
        continue-on-error: true
